در ابتدا یورکیت را نصب کردیم و سپس ورژن های مختلف جاوا را با آن تست کردیم تا جاوا 18 با آن کار کرد.
پس از نصب یورکیت افزونه آن به اینتلیجی اضافه شد.
![image](https://user-images.githubusercontent.com/87147901/235207901-2446e50b-0449-4492-9130-ec6231735b8e.png)
با اعداد 4 و 5 و 6 برنامه را ران میکنیم و میبینیم که پس از مدتی به مشکل میخورد. نمودار های برنامه یورکیت:

![image](https://user-images.githubusercontent.com/87147901/235208126-12b10485-40ad-4008-a375-8c909271cbda.png)
در این شکل می توانیم ببینیم که در آخرین لحظه ها فانکشن های مین و تمپ در سی پی یو در حال اجرا بوده اند.
![image](https://user-images.githubusercontent.com/87147901/235208455-2c9fc11e-20f0-464a-a62f-f19c6d51f65c.png)
در این شکل می توانیم ببینیم که برنامه پس از پر شدن هیپ در تابع تمپ به مشکل خورده و از اجرا خارج شده است.

برای قسمت دوم برنامه ما از برنامه ای استفاده کردیم که یک عدد را تحت عنوان ورودی میگیرد و آن را به توان 1000000000 می رساند. درحالت اول این کار را به کمک دو فور تو در تو انجام دادیم.
![image](https://user-images.githubusercontent.com/87147901/235213796-1bbd1280-fad1-4848-830d-762553cb26bc.png)

در شکل پایین میتوانیم ببینیم که با این روش اجرای برنامه چه مقدار سی پی یو مصرف کرد.
![image](https://user-images.githubusercontent.com/87147901/235213829-d23bd3ba-812b-4b1b-9820-86cc0d691fda.png)
و همچنین مموری
![image](https://user-images.githubusercontent.com/87147901/235213766-4fd2f1fe-1bbc-4003-90a5-8f3c13235afc.png)
اما در حالت بعد به جای استفاده از فور های تو در تو از تابع توان خود جاوا استفاده کردیم.
![image](https://user-images.githubusercontent.com/87147901/235213936-0b7ca0a1-aeac-4fab-a693-82fec12859c5.png)
در این حالت می توانیم ببینیم که برنامه بسیار سریع اجرا شد و مصرف سی پی یو آن بسیار پایین بود.
![image](https://user-images.githubusercontent.com/87147901/235214055-bed649d3-b47e-48cd-b83c-93e713aae7af.png)
برای اینکه تعداد عملیات بالا باشد ولی عددی که میخواهد تولید شود زیاد نباشد در هر دو حالت عدد یک را به برنامه دادیم.
